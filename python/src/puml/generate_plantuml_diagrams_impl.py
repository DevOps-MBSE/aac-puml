"""The AaC Generate PlantUML Diagrams plugin implementation module."""

# NOTE: It is safe to edit this file.
# This file is only initially generated by aac gen-plugin, and it won't be overwritten if the file already exists.

# There may be some unused imports depending on the definition of the plugin...but that's ok
import yaml

from os import path, remove
from typing import Callable

# from aac.context.language_context import LanguageContext
from aac.context.definition import Definition
from aac.execute.aac_execution_result import (
    ExecutionResult,
    ExecutionStatus,
    ExecutionMessage,
    MessageLevel,
)
from aac.in_out.writer import write_file
from aac.in_out.parser._parse_source import parse

from .helpers.sequence_helpers import _get_use_case_participants, _get_use_case_steps
from .helpers.object_helpers import _get_object_data

plugin_name = "Generate PlantUML Diagrams"


def before_puml_component_check(
    architecture_file: str, output_directory: str, run_check: Callable
) -> ExecutionResult:
    """
    Run the Check AaC command before the puml-component command.

    Args:
        architecture_file (str): A path to a YAML file containing an AaC-defined system from which to
                                 generate a PlantUML component diagram.
        output_directory (str): The output directory into which the PlantUML (.puml) diagram file
                                will be written.
        run_check (Callable): Callback reference to the run_check method from the Check plugin.

    Returns:
        The results of the execution of the check command.
    """
    return run_check(architecture_file, False, False)


def puml_component(architecture_file: str, output_directory: str) -> ExecutionResult:
    """
    Business logic for allowing puml-component command to perform the conversion of an AaC-defined system to a PlantUML component diagram.

    Args:
        architecture_file (str): A path to a YAML file containing an AaC-defined system from which to
                                 generate a PlantUML component diagram.
        output_directory (str): The output directory into which the PlantUML (.puml) diagram file
                                will be written.

    Returns:
        results of the execution of the puml-component command.
    """
    messages = []

    status = ExecutionStatus.SUCCESS
    msg = ExecutionMessage(
        f"Wrote PUML Component Diagram(s) to {output_directory}/.",
        MessageLevel.INFO,
        None,
        None,
    )
    messages.append(msg)

    return ExecutionResult(plugin_name, "puml-sequence", status, messages)


def after_puml_component_generate(
    architecture_file: str, output_directory: str, run_generate: Callable
) -> ExecutionResult:
    """
    Run the Generate generate command after the puml-component command.

    Args:
        architecture_file (str): A path to a YAML file containing an AaC-defined system from which to
                                 generate a PlantUML component diagram.
        output_directory (str): The output directory into which the PlantUML (.puml) diagram file
                                will be written.
        run_generate (Callable): Callback reference to the run_reference method from the Generate plugin.

    Returns:
        The results of the execution of the check command.
    """

    puml_component_generator_file = path.abspath(
        path.join(path.dirname(__file__), "./generators/component_diagram_generator.aac")
    )
    return run_generate(
        aac_plugin_file=architecture_file,
        generator_file=puml_component_generator_file,
        code_output=output_directory,
        test_output="",
        doc_output="",
        no_prompt=True,
        force_overwrite=True,
        evaluate=False,
    )


def before_puml_sequence_check(
    architecture_file: str, output_directory: str, classification: str, run_check: Callable
) -> ExecutionResult:
    """
    Run the Check AaC command before the puml-sequence command.

    Args:
        architecture_file (str): A path to a YAML file containing an AaC-defined use case from which
                                 to generate a PlantUML sequence diagram.
        output_directory (str): The output directory into which the PlantUML (.puml) diagram file
                                will be written.
        classification (str): The level of classification for the output diagram file.
        run_check (Callable): Callback reference to the run_check method from the Check plugin.

    Returns:
        The results of the execution of the check command.
    """
    return run_check(architecture_file, False, False)


def puml_sequence(architecture_file: str, output_directory: str, classification: str) -> tuple[list[str], ExecutionResult]:
    """
    Business logic for allowing puml-sequence command to perform the conversion of an AaC-defined use case to PlantUML sequence diagram.

    Args:
        architecture_file (str): A path to a YAML file containing an AaC-defined use case from which
                                 to generate a PlantUML sequence diagram.
        output_directory (str): The output directory into which the PlantUML (.puml) diagram file
                                will be written.
        classification (str): The level of classification for the output diagram file.

    Returns:
        sequence_files (list[str]): The list of sequence yaml file(s) to use in generating the output sequence diagram(s).
        ExecutionResult of the puml-sequence command for the PUML plugin.
    """
    # Initialize ExecutionResult for the puml-sequence command
    status = ExecutionStatus.GENERAL_FAILURE
    messages: list[ExecutionMessage] = []

    # Establish necessary data holders for sorting through the definitions
    use_case_definitions: dict = {}
    use_case_actors: dict = {}
    use_case_steps: dict = {}
    properties: dict = {}
    sequence_files: list[str] = []

    # Parse the input file to extract the definitions to sort
    parsed_definitions: list[Definition] = parse(architecture_file)

    # Sort through the parsed definitions into their top level categories
    for definition in parsed_definitions:
        if definition.get_root_key() == "usecase":
            use_case_definitions[definition.name] = definition
        if definition.get_root_key() == "actor":
            use_case_actors[definition.name] = definition
        if definition.get_root_key() == "usecase_step":
            use_case_steps[definition.name] = definition

    # Take a single use case at a time to extract participant and step data
    for use_case_definition in use_case_definitions:
        use_case_title = use_case_definitions[use_case_definition].name
        use_case = use_case_definitions[use_case_definition].structure["usecase"]

        participants = _get_use_case_participants(use_case=use_case, use_case_actors=use_case_actors)
        sequences = _get_use_case_steps(use_case=use_case, use_case_steps=use_case_steps)

        properties["usecase"] = {
            "name": use_case_title,
            "participants": participants,
            "sequences": sequences,
            "classification": classification
        }

        # Write use case data to new temp file for populating the diagram from in generate
        new_sequence_file = path.abspath(path.join(path.dirname(__file__), f"./{use_case_title}_sequence_diagram_content.yaml"))
        properties_yaml = yaml.dump(properties, default_flow_style=False)
        write_file(uri=new_sequence_file, content=properties_yaml, overwrite=True)

        sequence_files.append(new_sequence_file)

    # Check for if the passed file actually contained use case definitions and update ExecutionResult
    if len(use_case_definitions) > 0:
        status = ExecutionStatus.SUCCESS
        msg = ExecutionMessage(
            f"Wrote PUML Sequence Diagram(s) to {output_directory}",
            MessageLevel.INFO,
            None,
            None,
        )
    else:
        msg = ExecutionMessage(
            "No applicable use case definitions to generate a sequence diagram.",
            MessageLevel.ERROR,
            None,
            None,
        )
    messages.append(msg)

    return sequence_files, ExecutionResult(plugin_name, "puml-sequence", status, messages)


def after_puml_sequence_generate(
    architecture_file: str, output_directory: str, classification: str, run_generate: Callable
) -> ExecutionResult:
    """
    Run the Generate generate command after the puml-sequence command.

    Args:
        architecture_file (str): A path to a YAML file containing an AaC-defined use case from which to
                                 generate a PlantUML sequence diagram.
        output_directory (str): The output directory into which the PlantUML (.puml) diagram file
                                will be written.
        classification (str): The level of classification for the output diagram file.
        run_generate (Callable): Callback reference to the run_generate method from the Generate plugin.

    Returns:
        The results of the execution of the generate command.
    """
    puml_sequence_generator_file = path.abspath(
        path.join(path.dirname(__file__), "./generators/sequence_diagram_generator.aac")
    )
    sequence_files, execution_status = puml_sequence(architecture_file=architecture_file, output_directory=output_directory,
                                                     classification=classification)

    for sequence_file in sequence_files:
        generate_result = run_generate(aac_plugin_file=sequence_file,
                                       generator_file=puml_sequence_generator_file,
                                       code_output=output_directory,
                                       test_output="",
                                       doc_output="",
                                       no_prompt=True,
                                       force_overwrite=True,
                                       evaluate=False,
                                       )
        remove(sequence_file)
    return generate_result


def before_puml_object_check(
    architecture_file: str, output_directory: str, run_check: Callable
) -> ExecutionResult:
    """
    Run the Check AaC  command before the puml-object command.

    Args:
        architecture_file (str): A path to a YAML file containing an AaC-defined system from which to
                                 generate a PlantUML object diagram.
        output_directory (str): The output directory into which the PlantUML (.puml) diagram file
                                will be written.
        run_check (Callable): Callback reference to the run_check method from the Check plugin.

    Returns:
        The results of the execution of the check command.
    """
    return run_check(architecture_file, False, False)


# ----------------------------------
#   LEGACY REFERENCE CODE
# ----------------------------------
# def puml_object(architecture_file: str, output_directory: str) -> PluginExecutionResult:
#     """
#     Convert an AaC model to Plant ULM object diagram.

#     Args:
#         architecture_file: str: Path to a yaml file containing an AaC usecase from which to generate a Plant UML object diagram.
#         output_directory (str): Output directory for the PlantUML (.puml) diagram file (optional)
#     """
#     architecture_file_path = os.path.abspath(architecture_file)

#     def generate_object_diagram(definitions: list[Definition]):
#         model_definitions = get_definitions_by_root_key("model", definitions)

#         object_declarations = []
#         object_compositions = {}
#         for model_definition in model_definitions:
#             model_name = model_definition.name
#             object_declarations.append(model_name)

#             for component in search_definition(model_definition, ["model", "components", "type"]):
#                 if model_name not in object_compositions:
#                     object_compositions[model_name] = set()

#                 object_compositions.get(model_name, set()).add(component)

#         object_hierarchies = []
#         for parent in object_compositions:
#             for child in object_compositions.get(parent, {}):
#                 object_hierarchies.append({"parent": parent, "child": child})

#         aac_file_name = extract_aac_file_name(architecture_file)
#         generated_filename = get_generated_file_name(aac_file_name, OBJECT_STRING, model_name, output_directory)
#         return [
#             {
#                 "filename": generated_filename,
#                 "objects": object_declarations,
#                 "object_hierarchies": object_hierarchies,
#             }
#         ]

#     with plugin_result(
#         plugin_name,
#         generate_diagram_to_file,
#         architecture_file_path,
#         output_directory,
#         OBJECT_STRING,
#         generate_object_diagram,
#     ) as result:
#         return result
def puml_object(architecture_file, output_directory) -> [str, ExecutionResult]:
    """
    Business logic for allowing puml-object command to perform the conversion an AaC-defined system to PlantUML object diagram.

    Args:
        architecture_file (str): A path to a YAML file containing an AaC-defined system from which to
                                 generate a PlantUML object diagram.
        output_directory (str): The output directory into which the PlantUML (.puml) diagram file
                                will be written.

    Returns:
        yaml data to be passed to the generate method
        The results of the execution of the puml-object command.
    """
    messages: list[ExecutionMessage] = []
    parsed_file = parse(architecture_file)
    object_data = _get_object_data(parsed_file) #gets back a list of dictionaries containing a list of object_declarations, and a list of object hierarchies
    if len(object_data) < 1:
        return None, ExecutionResult(plugin_name, "puml-object", ExecutionStatus.GENERAL_FAILURE, [ExecutionMessage("No models found", MessageLevel.INFO, None, None)])

    yaml_list = []
    for model in object_data:
        yaml_list.append([{"model": model}])

    new_file = ""
    for yaml_object in yaml_list:
        new_file = new_file + yaml.safe_dump_all(yaml_object, default_flow_style=False, sort_keys=False, explicit_start=True)
    print(new_file)
    f = open("test_output.txt", "w")
    f.write(new_file)
    f.close

    status = ExecutionStatus.SUCCESS
    msg = ExecutionMessage(
        f"Wrote PUML Object Diagram(s) to {output_directory}",
        MessageLevel.INFO,
        None,
        None,
    )
    messages.append(msg)

    return new_file, ExecutionResult(plugin_name, "puml-object", status, messages)


def after_puml_object_generate(
    architecture_file: str, output_directory: str, run_generate: Callable
) -> ExecutionResult:
    """
    Run the Generate generate command after the puml-object command.

    Args:
        architecture_file (str): A path to a YAML file containing an AaC-defined system from which to
                                 generate a PlantUML object diagram.
        output_directory (str): The output directory into which the PlantUML (.puml) diagram file
                                will be written.
        run_generate (Callable): Callback reference to the run_generate method from the Generate plugin.

    Returns:
        The results of the execution of the generate command.
    """
    arch_file_content, execution_status = puml_object(architecture_file, output_directory)

    puml_object_generator_file = path.abspath(
        path.join(path.dirname(__file__), "./generators/object_diagram_generator.aac")
    )
    return run_generate(
        aac_plugin_file=arch_file_content,
        generator_file=puml_object_generator_file,
        code_output=output_directory,
        test_output="",
        doc_output="",
        no_prompt=True,
        force_overwrite=True,
        evaluate=False,
    )


def before_puml_requirements_check(
    architecture_file: str, output_directory: str, run_check: Callable
) -> ExecutionResult:
    """
    Run the Check AaC command before the puml-requirements command.

    Args:
        architecture_file (str): A path to a YAML file containing an AaC-defined system from which to
                                 generate a PlantUML requirements diagram.
        output_directory (str): The output directory into which the PlantUML (.puml) diagram file
                                will be written.
        run_check (Callable): Callback reference to the run_check method from the Check plugin.

    Returns:
        The results of the execution of the check command.
    """
    return run_check(architecture_file, False, False)


def puml_requirements(architecture_file, output_directory) -> ExecutionResult:
    """
    Business logic for allowing puml-requirements command to perform the conversion of an AaC-defined system to a requirements diagram in PlantUML format.

    Args:
        architecture_file (str): A path to a YAML file containing an AaC-defined system from which to
                                 generate a PlantUML requirements diagram.
        output_directory (str): The output directory into which the PlantUML (.puml) diagram file
                                will be written.

    Returns:
        The results of the execution of the puml-requirements command.
    """

    # TODO: implement plugin logic here
    status = ExecutionStatus.SUCCESS
    messages: list[ExecutionMessage] = []
    msg = ExecutionMessage(
        f"Wrote PUML Requirement Diagram(s) to {output_directory}",
        MessageLevel.INFO,
        None,
        None,
    )
    messages.append(msg)

    return ExecutionResult(plugin_name, "puml-requirements", status, messages)


def after_puml_requirements_generate(
    architecture_file: str, output_directory: str, run_generate: Callable
) -> ExecutionResult:
    """
    Run the Generate generate command after the puml-requirements command.

    Args:
        architecture_file (str): A path to a YAML file containing an AaC-defined system from which to
                                 generate a PlantUML requirements diagram.

        output_directory (str): The output directory into which the PlantUML (.puml) diagram file
                                will be written.
        run_generate (Callable): Callback reference to the run_generate method from the Generate plugin.

    Returns:
        The results of the execution of the generate command.
    """
    puml_requirements_generator_file = path.abspath(
        path.join(path.dirname(__file__), "./generators/requirements_diagram_generator.aac")
    )
    return run_generate(
        aac_plugin_file=architecture_file,
        generator_file=puml_requirements_generator_file,
        code_output=output_directory,
        test_output="",
        doc_output="",
        no_prompt=True,
        force_overwrite=True,
        evaluate=False,
    )
